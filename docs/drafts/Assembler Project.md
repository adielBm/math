The Project: to write an assembler for a specific assembly language defined here specifically for this project.
## Hardware

- The computer in the project consists of: 
	- CPU (Central Processing Unit)
		- [[#Registers]]
	- Memory (stack). Some of the memory serves as a stack (RAM).
		- size: 4096 cells. (words)
		- addresses ranging from 0 to 4095 (decimal).
		- cell (word) size: 14 bits, 
		- The bits in each word are numbered similarly to the register.
- This computer supports only **integers** (positive & negative). there is no support for real numbers. 
	- Arithmetic is performed using the [[Data Storage#Two's complement|Two's complement]] method.
- There is also support for characters, represented in ASCII code

## Registers

- 8 general registers named `r0, r1, r2, r3, r4, r5, r6, r7`
	- Register: 14 bits. 
		- The least significant bit (right-most) is bit 0 
		- The most significant bit (left-most) is bit 13
		- The register names are always written with a lowercase `r`
- A register named **Program Status Word** (PSW), which contains flags characterizing the processor's state at any given moment.


## Machine Instructions

### Machine Instruction Structure

- Each machine instruction (הוראת מכונה) is encoded into a sequence of consecutive **memory words**
- range: min: one word, max: 5 words, depending on the addressing modes used (see later #todo )
- In the output file containing the machine code generated by the assembler, each word is encoded in the Base 4 Encoded as defined below (see explanations and examples later):


#### The first word

The structure of the first word is always the same. The structure of the first word in an instruction is as follows: (`xxxx.xxxx.xx.xx.xx`)

| Bits      | `10 11 12 13` | `6 7 8 9` | `4 5`                | `2 3`                     | `0 1`     |
| --------- | ------------- | --------- | -------------------- | ------------------------- | --------- |
| **Field** | Not used      | `opcode`  | Operand Ad. (Source) | Operand Ad. (Destination) | `A, R, E` |

- Bits `0-1` (the [[#A.R.E field]]):
	- In the first word of an instruction, these bits are always set to zero (`00`).
- Bits `2-3`: Encode the number of the addressing mode for the **destination operand**. If there is no destination operand in the instruction, the value of these bits is `0`.
- Bits `4-5`: Encode the number of the addressing mode for the **source operand**. If there is no source operand in the instruction, the value of these bits is `0`.
- Bits `6-9`: In the first word of the instruction, these bits represent the **operation code** (opcode). Each opcode is symbolically represented in assembly language by an **operation name**.
- Bits `10-13`: not used and their value is `0`.

### Machine instructions specification

- **Program Counter** (PC)
	- This is an **internal register** of the processor (not a general register), which at any given moment contains the memory address where the current instruction being executed is located (always referring to the address of the first word of the instruction).

The machine instructions are divided into three groups, according to the number of operands required for the operation.

- The **first set** of instructions
	- number of operands: `2`
	- set: `mov, cmp, add, sub, lea`
- The **second set** of instructions:
	- number of operands: `1`
	- set: `not, clr, inc, dec, jmp, bne, red, prn, jsr`
	- The Instruction Encoding: is the same as the distention operand in a command with two operands. 
	- In this case, the field of the source operand (`4-5` bits ) in the first word in the coding of the instruction it is meaningless, and therefore will contain `00`.
- The **third set** of instructions:
	- number of operands: `0`
	- set: `rts, hlt`
	- The Instruction Encoding: only one word
	- the field of the source & destination operands in the first word are not used, thus there are zero (???)

#### Operation Table

| operands num | opcode | operation name |
| ------------ | ------ | -------------- |
| 2            | 0      | mov            |
| 2            | 1      | cmp            |
| 2            | 2      | add            |
| 2            | 3      | sub            |
| 1            | 4      | not            |
| 1            | 5      | clr            |
| 2            | 6      | lea            |
| 1            | 7      | inc            |
| 1            | 8      | dec            |
| 1            | 9      | jmp            |
| 1            | 10     | bne            |
| 1            | 11     | red            |
| 1            | 12     | prn            |
| 1            | 13     | jsr            |
| 0            | 14     | rts            |
| 0            | 15     | hlt            |
#### 1st set 

- The `mov` (Move) instruction is used to transfer data between registers, memory locations, and immediate values.
	- Syntax: `mov source, destination`
	- Example: `mov A, r1` copies the value from variable `A` to register `r1`.
- The `cmp` (Compare) instruction performs a comparison between its two operands. the content of the destination operand (the second) is subtracted from the content of the source operand (the first), without saving the result of the subtraction. The subtraction operation updates a flag called the `Z` variable in the status register (PSW).
	- Syntax: `cmp operand1, operand2`
	- Example: `cmp A, r1`, If the contents of the variable `A` equal to the contents of register `r1` then the zero flag, `Z`, in the status register (PSW) will be turn on, otherwise the flag will be reset.
- The `add` (Addition) instruction performs integer addition between two operands and stores the result in the destination operand.
	- Syntax: `add source, destination`
	- Example: `add A, r0` adds the value in register `A` to the value in register `r0`.
- The `sub` (Subtraction) instruction performs integer subtraction between two operands and stores the result in the destination operand.
    - Syntax: `sub source, destination`
    - Example: `sub #3, r1`, register `r1` receives the result of subtracting the value `3` from the current contents of register `r1`.
- The `lea` (Load Effective Address) instruction places the address in memory represented by the label in the first operand (the source), to the second operand (the destination operand)
    - It does not access memory; it only computes the address.
    - Syntax: `lea .....???` 
    - Example: `lea HELLO, r1` The address represented by the label `HELLO` is placed in the `r1` register

#### 2nd set 

| Instruction | Description                                                                                                    | Syntax         | Example                              |
| ----------- | -------------------------------------------------------------------------------------------------------------- | -------------- | ------------------------------------ |
| `not`       | Sets the complement of the value in the specified operand                                                      | `not [op]`     | `not r2` will perform `r2 ← not r2`  |
| `clr`       | Clears the value in the specified register, setting it to 0                                                    | `clr [op]`     | `clr r2` will perform `r2 ← 0`       |
| `inc`       | Increments the value in the specified operand by 1                                                             | `inc [op]`     | `inc r2` will perform `r2 ← r2 + 1`  |
| `dec`       | Decrements the value in the specified operand by 1                                                             | `dec [op]`     | `dec C` will perform `C ← C - 1`     |
| `jmp`       | Unconditional jump to the instruction specified by the label.                                                  | `jmp LABEL`    | `jmp LINE` will perform `PC ← LINE`  |
| `bne`       | Conditional branch if the `Z` flag in the status register is not equal to zero.                                | `bne LINE`     | If `Z` is not zero, then `PC ← LINE` |
| `red`       | Reads a character from `stdin` and stores its ASCII code in the specified operand.                             | `red REGISTER` | `red r1`                             |
| `prn`       | Prints the ASCII character represented by the operand to `stdout`.                                             | `prn OPERAND`  | `prn r1`                             |
| `jsr`       | Calls a subroutine, pushing the current program counter onto the stack and updating PC to the specified label. | `jsr LABEL`    | `push(PC)`, then `PC ← FUNC`         |



- `bne` (**B**ranch if **N**ot **E**qual to Zero) - Conditional branch. The program pointer (PC) will receive the value of the destination operand,  if the value of the flag `Z` in the status register (PSW) is `0`. (Reminder: The Z flag is set in the "cmp" command.)
	- Syntax `bne ....??`
	- Example `bne LINE`, if the value of the flag `Z` in the status register (PSW) is `0`, then `PC ← LINE`
- `red` (Read) - Reads a character from `stdin` (The Standard Input), and stores its ASCII code in the specified register
   - Syntax `red REGISTER`
   - Example: `red r1`
- `prn` (Print) - Prints the ASCII character represented by the operand to `stdout` (The Standard Output)
	- Syntax `prn OPERAND`
	- Example: `prn r1`
- `jsr` (Jump to Subroutine) - Calls a subroutine. The current program counter (PC) is pushed onto the stack, and the operand is inserted into PC
   - Syntax: `jsr LABEL`
   - Example: `jsr FUNC` will do `push(PC)` and then `PC ← FUNC`

#### 3rd set 

- `rts` (**R**e**T**urn from **S**ubroutine) 
	- Back from routine. The value at the top of the computer's stack is taken from the stack, and inserted into the program pointer (PC, Program Counter).
	- `rts` will do `PC ← pop()`
- `hlt` (Halt) Stopping the program

### A.R.E. field 

- At each word in the machine code of an instruction (not of data), the assembler inserts information for the linking and loading process. This is the A,R,E field. The information will be used to make corrections to the code every time it is loaded into memory for execution. The assembler builds from scratch code that is intended to be loaded starting from the start address. The fixes will make it possible to load the code in a different place each time, without having to repeat the assembly process.
- The A.R.E field is added to each word in the instruction encoding

| Encoding Type   | Bits | Meaning                                                                                                                                                                                                                         | Example                                                                                                 |
| --------------- | ---- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- |
| Absolute (A)    | `00` | indicate that the content of the word does not depend on the place in memory where the machine code of the program will actually be loaded during its execution. (thus, requiring no changes in the linkage and loading stages) | a word containing an immediate operand                                                                  |
| Relocatable (R) | `10` | indicate that the content of the word depends on the place in memory where the machine code of the program will actually be loaded when it is executed (thus, requiring changes linkage & loading)                              | a word containing the address of a label defined in the source file                                     |
| External (E)    | `01` | indicates that the content of the word depends on the value of an external symbol (thus, requiring changes linkage & loading)                                                                                                   | a word containing the address of an external label, i.e. a label that is not defined in the source file |

### Addressing Modes

In our language, there are four addressing modes, marked with the numbers `0`, `1`, `2`, and `3`.

Using addressing modes requires encoding additional data words in the machine code of the instruction.

If a command has one operand, there will be one additional data word. 

If a command has two operands, there may be two additional data words, or one shared data word for both operands, depending on the addressing modes used (see specifications below).

When encoding the instruction, if there are two additional data words, the first data word refers to the source operand, and the second refers to the destination operand.

- In each additional data word, bits `0-1` represent the `A, R, E` field.

Description of the addressing modes in our machine:

| Value | Addressing Mode      | content                | Additional Word(s) |                   |
| ----- | -------------------- | ---------------------- | ------------------ | ----------------- |
| `0`   | Immediate Addressing | `#integer` or `#const` | 1                  | מיעון מיידי       |
| `1`   | Direct Addressing    | `label`                | 1                  | מיעון ישיר        |
| `2`   | Index Addressing     | `array[index]`         | 2                  | מיעון אינדקס קבוע |
| `3`   | Register Addressing  | `register`             | 1                  | מיעון רגיסטר ישיר |

#### (0) Immediate Addressing (מיעון מיידי) 

- The operand begins with `#` followed by a decimal integer
	- Example: `mov #-1,r2`. The first operand is given in an immediate addressing. The instruction writes the value `-1` to register `r2` 
- The constant name defined in the program by `.define` will appear instead of the number (see [[#Constant Definition Statement (משפט הגדרת קבוע)]]).
	- Example: given the definition of the constant: `.define size = 8`, then in the instruction: `mov #size, r1` the first operand is given in an immediate addressing, when the number `8` is represented by the constant named `size`. The instruction writes the value `8` to register `r1`

- Additional information word in the instruction encoding: 
	- `xxxxxxxxxxxx.00`
	- `0-1` bits - for [[#A.R.E. field]]. in this mode always `00` (absolute)
	- `2-13` bits - contains the operand itself, which is an integer using the 2's complement method, represented with a width of 12 bits

#### (1) Direct Addressing (מיעון ישיר) 


- Additional information word in the instruction encoding: 
	- `xxxxxxxxxxxx.xx`
	- `0-1` bits - for [[#A.R.E. field]]. in this mode is either `10` (relocatable) or `01` (external). (depending on the type of address - internal or external)
	- `2-13` bits - The address of the operand represented as an unsigned number (12 bits)

- The operand is a label that has already been declared or will be declared later in the file. The statement is made by writing a label at the beginning of the landing `.data` or `.string` or at the beginning of an instruction of the program, or using an operand of the `.extern`


- Example: given `x: .data 23`, then the instruction `dec x` decreases by 1 the content of the word at address `x` in memory (the variable `x`).

#### (2) Index Addresing (מיעון אינדקס קבוע) 

- Usage: This addressing mode is used to access to an array member by index. The array is in memory. Each member of the array is a size word (14 bits)

- Additional information words in the instruction encoding: 
	- The **1st additional word** consists of the **base address** (the address of the beginning of the array) (12 bits), and the ARE field (2 bits). (as in the additional word in [[#(1) Direct Addressing (מיעון ישיר)]]) 
	- The **2nd additional word** consists of the index of the element in the array to be accessed (12 bits), and the ARE field (2 bits).  (as in the additional word in [[#(0) Immediate Addressing (מיעון מיידי)]])


- The operand consists of a label indicating the **base address** (the address of the beginning of the array), followed by the index in the array to be accessed in square brackets. (The index can be given by a numerical constant defined with `.define`)
- The array indexes start from 0
- Examples:
	- Given a definition of an array `x: .data 23,25,19,30`, then the instruction `mov x[2],r2` will copy the number `19` found in index `2` in the array `x` to the register `.r2`
	- Given the definition of the array `x` above, as well as the constant definition `.define k=1` then the instruction: `mov r2,x[k]` will copy the content of the register `r2` to the word at index `1` in the array `x` (the previous content `25` will be overwritten)

#### (3) Register Addressing (מיעון רגיסטר ישיר)


- The operand is a name of register.

- The instruction encoding: 
	- If the register is used as a destination operand, an additional data word will encode in bits `2-4` the number of the register. 
		- `000000000.xxx.00`
	- Whereas if the register is used as a source operand, the register number will be encoded in bits `5-7` of the data word. 
		- `000000.xxx.000.00`
	- If the command has two operands and both are direct register addressing, they will share one common data word, where bits `2-4` are for the destination register, and bits `5-7` are for the source register. 
		- `000000.xxx.xxx.00`
		- Example: the instruction `mov r1,r2` copies the contents of register `r1` to register `r2`. the encoding will be `000000.010.001.00` (In this example, both operands are in the direct register addressing mode, so they will share one additional data word in common.) 
	- A pair of bits of the A.R.E field are added to the data word (the value of this field is always `00` for this addressing mode). 
	- Other unused bits in the data word will contain 0s.

___

> Note: It is allowed to refer to the label even before it is declared, but provided that it is indeed declared somewhere in the file

# Assembly Language
## Macros

Reusable, symbolic names representing a sequence of instructions or other statements.

- **Macros** are pieces of code that include statements.
	- In the program you can define a macro and use it in different places in the program. The use of a macro from a certain place in the program will cause the macro to be allocated to that place. 

#### Defining & Using

In the following example the name of the macro is `m_mcr`

```
mcr m_mcr
    inc r2     
	mov  A,r1  
endmcr   
```

Using a macro is simply mentioning its name. For example, if somewhere in the program it is written:

```
.
.
.
m_mcr
.
.
m_mcr
.
.
.
```

Then the program after macro retirement will look like this.

```
.
.
.
inc r2     
mov  A,r1  
.
.
inc r2     
mov A,r1  
.
.
.
```


#### Assumptions & guidelines

- The name of an instruction or directive cannot be the name of a macro.
- There are no nested macro definitions (no need to check this).
- It can be assumed that each macro line in the source code has a closure with an `endmcr` line (there is no need to check this).
- Defining a macro will always be before calling the macro (no need to check it).


## Statements

- The source file consist of lines (max length `80`) that contains statements. (each statements is on a separate line, using `\n`)
- A **statement** is individual line or units of code in a program
### Statement Types

- **Empty Statement** - This is a line that contains only whitespace characters, i.e. only the characters ` ` and `\t` (spaces and tabs). The line may not contain any characters (except for the `\n` character), which means the line is empty.
- **Comment Statement** - This is a line in which the first character is `;` (semicolon). The assembler should completely ignore this line.
- [[#Directive Statement (משפטי הנחיה)]] - instructs the assembler what to do when it runs on the source program. A directive statement may cause the allocation of memory and the initialization of program variables, but it does not produce an encoding of machine instructions intended to be executed when the program runs.
- [[#Instruction Statement (משפטי הוראה)]] - This is a statement that produces a coding of machine instructions to be executed when the program runs. The statement consists of the name of an instruction that the processor must execute, and a description of the instruction's operands.
- [[#Constant Definition Statement (משפט הגדרת קבוע)]] - This is a statement that can be used to define a symbolic name that represents a numerical constant. During the coding of the program, wherever the name appears in the code, it will be replaced by the numerical constant. This statement by itself does not generate code and does not allocate memory.

#### Directive (משפטי הנחיה)

- Structure 
	- A **label** definition can appear optionally at the beginning of the statement. 
	- The **name** of the directive appears
		- A directive's name begins with the character `.` (period) followed by lower case characters only.
	- **Parameters** will appear after the name of the directive (the number of parameters according to the directive).

> **Important:** the words in the machine code that are created from the directive statement are not includes the [[#A.R.E. field]] and the encoding fills all 14 bits of the word.

#####  `.data`

- The parameters of the directive `.data` are valid integers (one or more) separated by the character `,` (e.g. `.data 7, -57, +17,9`). 
	- Note: spaces and tabs can be before or after commas, but there must be exactly one comma between two numbers, and no comma after the last number or before the first number.
- The directive `.data` instructs the assembler to allocate space in the **data image** (תמונת הנתונים), where the values of the parameters will be stored, and to advance the **data counter**, according to the number of values. if in `.data` a label is defined, then this label gets the value of the data counter (before the increase), and it is inserted into the symbol table. 
	- This makes it possible to refer to a specific place in the data image through the name of the label (in fact, this is a way to define a name of a variable). 
	- for example, if we write: `XYZ: .data 7, -57, +17,9` then 4 consecutive words will be assigned in the data image that will contain the numbers that appear in the instruction. The label `XYZ` is identified with the first word address. 
		- If we write the instruction: `mov XYZ, r1`, then, in the running time, the value `7` will be inserted into register `r1`. Likewise, the instruction: `lea XYZ, r1` will insert the value of label `XYZ` into register `r1` (i.e., the memory address where the value `7` is stored). 


##### `.string`

- The directive `.string` has one parameter, which is a valid string.
- The string characters are encoded according to the corresponding ASCII values, and inserted into the data image in order, each character in a separate word. At the end of the string, the character `\0` (the numerical value `0`) will be added, marking the end of the string. 
- The assembler's data counter increments by the string length plus one (for the null character). 
- If a label is defined, then that label gets the value of the data counter (before the increase) and is inserted into the symbol table, similar to what was done for `.data` (ie the value of the label will be the memory address where the string starts). 
	- For example, the directive: `STR: .string "abcdef"` allocates in the data image a sequence of 7 words, and initializes the words to the ASCII value of the characters, followed by the value 0 to mark the end of a string. The `STR` label is identified with the starting address of the string.

##### `.entry` 

- The directive `.entry` has one parameter which is the name of a label defined in the current source file (i.e. a label that receives its value in this file). 
- The purpose of the `.entry` directive is to characterize this label in a way that allows assembly code found in other source files to use it (as an instruction operand)
	- For example, the lines `.entry  HELLO` and `HELLO:  add #1, r1` tell the assembler that the `HELLO` label defined in the current file can be referenced in another file. 
- Note: A label defined at the beginning of the entry line. is meaningless and the assembler ignores this label (the assembler may issue a warning message).

##### `.extern`

#todo 

-  The directive `.extern` to prompt 'extern.' parameter and is the name of a label that is not defined in the current source file. The purpose of the instruction is to inform the assembler that the label is defined in another source file, and that the assembly code in the current file makes use of the label. We will note that this instruction corresponds to the instruction 'entry.' that appears in the file where the label is defined. In the linking phase, a match will be made between the value of the label, as determined in the machine code of the file that defined the label, and the coding of the instructions that use the label in other files (the linking phase is not relevant to this document). For example, the directive 'extern.' The corresponding to the 'entrry' directive from the previous example would be: .extern Note: the same label cannot be defined in the same file as both entrry and extern (in the examples above, the label HELLO). Attention: label defined at the beginning of the extern line. is meaningless and the assembler ignores this label (the assembler may issue a warning message). HELLO

#### Instruction Statement (משפטי הוראה)

- **label** (optional)
	- If a label is defined on the instruction line, then it will be inserted into the symbol table (see [[#Two-Pass Assembler]])
	- The value of the label will be the address of the first word of the instruction within the code image that the assembler builds.
- `operation-name` (one of 16 [[#Machine instructions specification|operations]])
	- lower case
	- separated from the first operand using space(s) or tab(s).
- **operand(s)** 
	- 0-2, depending on operation type
	- separated by `,`. (can be space(s) and tab(s) on both sides the comma)

- Syntax 
	- (2 operands) `label: operation-name source-operand, target-operand` (e.g. `HELLO: add r7, B`)
	- (1 operand) `label: operation-name target-operand` (e.g.  `HELLO: bne XYZ`)
	- (no operand) `label: operation-name` (e.g. `END: hlt`)

#### Constant Definition Statement (משפט הגדרת קבוע)

- syntax: `.define constant-name = numeric constant`
- examples: 
	- `.define len = 4`
	- `.define init = -3`
- The idea is to represent a numerical constant using a symbolic name. Anywhere in the program where the name of a constant appears, the assembler will replace the name with the numerical constant to which it was defined when encoding the command into machine code.
- The reserved word `.define` is lowercase.
- The constant must be defined before its first use. 
- You must not define a label on a line that is a *constant definition statement*.
- **constant-name**
	- The syntax of the constant name is the same as that of a label. 
	- You must not define the same constant name more than once. 
	- The same symbol cannot be used both as the name of a constant and as a label in the same program. 
	- Assembly language reserved words (name of a register, name of a machine instruction or name of a directive) cannot be used as the name of a constant. 
- The character `=` separates the name of the constant and the numerical constant. White characters are allowed on both sides of the character. 
- The **numerical constant** is an integer in decimal base. 

- The constant name can be used anywhere in the assembly program where a numerical constant can appear, (i.e. an index in the direct index addressing mode, or a value in the immediate addressing mode, or an operand of the data landing.)  :Examples, (given the constant definitions above): 
	 - `mov x[len], r3` will copy the element at index `4` in the array `x` to register `r3`.
	 - `mov #init, r2` place the immediate value `-3` into register `r2`. 
	 - `.data len` assign a word in memory with an initial value of `4`.

### Fields in Statements

- A **label** is a symbol that is defined at the beginning of an instruction statements, or at the beginning of a `.data` or `.string` directive
	- A valid label begins with an alphabetic letter, followed by some series of alphabetic letters and/or digits
	- uppercase/lowercase
	- maximal length: 31 characters
	- **Label Definition:** A label definition ends with `:` (colon). This character is not part of the label, but only a mark indicating the end of the definition. The letter `:` must be adjacent to the label (without spaces).
	- The same label must not be defined more than once (of course in different lines). Uppercase and lowercase letters are treated differently.
	- Examples: `hEllo:`, `x:`, `He78902:`
	- **Reserved words**: (operation name, directive name, or register name)
		- Reserved words cannot also be used as a label name
	- Also, the same symbol must not be used both as a label and as the name of a macro or constant. 
	- **Label value**: The label receives its value according to the context in which it is defined. 
		- A label defined in the directives `.data`, `.string`, has the current value of the data counter
		- A label defined in an instruction line has the current value of the instruction counter (IC). (see [[#The First Pass]])
	- It is allowed in an instruction statement to use an operand that is a symbol that is not defined as a label in the current file, as long as the symbol is characterized as external (using `.extern` directive in the current file). 
- **Number**: valid number starts with an optional sign: `-` or `+` followed by some sequence of digits in decimal base. 
	- For example: `-5`, `76`, `+123` are valid numbers. 
	- Our assembly language does not support representation in a base other than decimal, and there is no support for non-integer numbers. 
- **String**: A valid string is a sequence of visible (printable) ASCII characters, enclosed in double quotes (the quotes are not considered part of the string). e.g. `"hello world"`.

# Assembler

- Assembler Process 
	- Construct a file containing machine code from a given file of a program written in assembly language.
		- Pre-Assembler
			- macro expansion
		- Assembler
	- Linkage. (Not part of the project)
	- Loading. (Not part of the project)

### Pre-Assembler

- When the assembler receives an assembly language program as input, it must first handle the macro expansion, and only then go over the program to which the macros were expanded. That is, the macro expansion will be done in the "pre-assembler" step, before the assembler phase (described later). 
- If the program does not contain a macro, the retirement program will be the same as the source program.

#### Example

An example of a pre-assembler step. The assembler accepts the following assembly language program:

```
.define sz=2
MAIN:       mov     r3,LIST[sz]
LOOP:       jmp     L1
            mcr m_mcr
                    cmp     r3, #sz
            bne     END
            endmcr
            prn     #-5
            mov     STR[5], STR[2]
            sub     r1, r4
            m_mcr
L1:         inc     K
            bne     LOOP
END:        hlt
.define len=4
STR:        .string "abcdef"
LIST:  .data 6,-9, len    
K:          .data   22
```

First, the assembler goes through the program and expands all the macros present in it. Only if this process ends successfully, you can move on to the next step. 

In this example, the program after the macro expansion will look like this:

```
.define sz=2
MAIN:       mov     r3,LIST[sz]
LOOP:       jmp     L1
            prn     #-5
            mov     STR[5], STR[2]
            sub     r1, r4
            cmp     r3,#sz
            bne     END
L1:         inc     K
            bne     LOOP
END:        hlt
.define len=4
STR:        .string "abcdef"
LIST:  .data 6,-9, len    
K:          .data   22
```

The program code, after macro expansion, will be saved in a new file, as will be explained later.

#### Pre-Assembler Algorithm

This is a skeletal algorithm for the pre-assembler process. 

>  Note: there is no obligation to use this particular algorithm

1. Read the next line from the source file. If the file ends, go to 9 (end).
2. Is the first field a macro name appearing in the macro table (e.g. `m_mcr`)? If yes, replace the macro name and copy all corresponding lines from the table to the file, go to 1. Otherwise, continue.
3. Is the first field `mcr` (start of macro definition)? If not, go to 6.
4. Set the `mcr exists` flag.
5. (Macro definition exists) Enter the macro table with the macro name (e.g., `m_mcr`).
6. Read the next line from the source file. If the source file ends, go to 9 (end).
   If the "mcr exists" flag is on and the endmcr label is not found, insert the line into the macro table and delete the line from the file. Otherwise (not a macro), go to 1.
7. Is the `endmcr` label found? If yes, delete the label from the file and continue. If not, go to 6.
8. Turn off the `mcr exists` flag. Go to 1. (End of macro definition saving).
9. End: Save the expanded macro file.

### Two-Pass Assembler

- Replaceing the operations names with the corresponding opcode by the [[#Operation Table]]
	- In the [[#Example]]: the operations names are `mov, jmp, prn, sub, cmp, inc, bne, hlt` 
- Replaceing symbols with the names of the places in memory where each data or instruction is located respectively
	- In the example: the symbols `K,STR, LIST, LI, MAIN, LOOP, END`
- Replaceing the names of the constants defined by `.define` with the numerical constants that are the values of the corresponding constants. 
	- In the example: the constants are `len` and `sz`

##### Example 

  Assume that the code snippet in the above example (instructions and data) is loaded into memory starting at address `100` (decimal). In this case we get the following "translation":
  
| Address (Decimal)                    | Source Code              | Explanation                                                                                                             | Binary Machine Code <br>(1-5 words of 14 bits)                                                 |
| ------------------------------------ | ------------------------ | ----------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
| 0100<br>0101<br>0102<br>0103         | `MAIN: mov r3, LIST[sz]` | 1st word of instruction<br>Source register 3<br>Address of label `LIST` (int array)<br>Value of constant `sz` (index 2) | 0000.0000.11.10.00<br>00000001100000<br>00001000010010<br>00000000001000                       |
| 0104<br>0105                         | `LOOP: jmp L1`           | Address of label L1                                                                                                     | 0000.1001.00.01.00<br>00000111100010                                                           |
| 0106<br>0107                         | `prn #-5`                | Immediate value `-5`                                                                                                    | 0000.1100.00.00.00<br>11111111101100                                                           |
| 0108<br>0109<br>0110<br>0111<br>0112 | `mov STR[5], STR[2]`     | Address of label `STR` (string)<br>Index 5<br>Address of label `STR`<br>Index 2                                         | 0000.0000.10.10.00<br>000001111100.10<br>000000000101.00<br>000001111100.10<br>000000000010.00 |
| 0113<br>0114                         | `sub r1, r4`             | -<br>Source register 1 and target register 4                                                                            | 0000.0011.11.11.00<br>000000.001.100.00                                                        |
| 0115<br>0116<br>0117                 | `cmp r3, #sz`            | -<br>Source register 3<br>Value of constant `sz` (immediate `#2`)                                                       | 0000.0001.11.00.00<br>000000.011.00000<br>000000000010.00                                      |
| 0118<br>0119                         | `bne END`                | - <br>Address of label `END`                                                                                            | 0000.1010.00.01.00<br>00000111110010                                                           |
| 0120<br>0121                         | `L1: inc K`              | -<br>Address of label `K` (integer)                                                                                     | 0000.0111.00.01.00<br>000010000111.10                                                          |
| 0122<br>0123                         | `bne LOOP`               | -<br>Address of label `LOOP`                                                                                            | 0000.1010.00.01.00<br>000001101000.10                                                          |
| 0124                                 | `END: hlt`               |                                                                                                                         | 0000.1111.00.00.00                                                                             |
| 0125                                 | `STR: .string "abcdef"`  | ASCII code `'a'`                                                                                                        | 00000001100001                                                                                 |
| 0126                                 |                          | ASCII code `'b'`                                                                                                        | 00000001100010                                                                                 |
| 0127                                 |                          | ASCII code `'c'`                                                                                                        | 00000001100011                                                                                 |
| 0128                                 |                          | ASCII code `'d'`                                                                                                        | 00000001100100                                                                                 |
| 0129                                 |                          | ASCII code `'e'`                                                                                                        | 00000001100101                                                                                 |
| 0130                                 |                          | ASCII code `'f'`                                                                                                        | 00000001100110                                                                                 |
| 0131                                 |                          | ASCII code `'\0'` (end of string)                                                                                       | 00000000000000                                                                                 |
| 0132<br>0133<br>0134                 | `LIST: .data 6, -9, len` | Integer 6 (first in array of 3 words)<br>Integer -9<br>Value of constant `len` (integer 4)                              | 00000000000110<br>11111111110111<br>00000000000100                                             |
| 0135                                 | `K: .data 22`            | Integer 22 (single word)                                                                                                | 00000000010110                                                                                 |

- Symbols table
	- The **symbol table** (טבלת הסמלים) is a structure that associates symbols in the source code with a numerical value (memory address or a constant value defined by `.define`)
	- The assembler builds the symbols table containing the values of all symbols. (for convert operands to binary written in addressing modes that use symbols (labels))
		- However, unlike the opcodes, which are known in advance, the addresses in memory for the symbols used by the program are not known, until the source program has read in its entirety and all the definitions of the symbols have been discovered.  For instance, in the next example, on the code above, the assembler **cannot** know that the symbol `END` is associated with `124` (decimal), and that the symbol `K` is associated with `135`, but only after all the lines of the program have been read. That is why the assembler's treatment of symbols is separated into two stages.
			- In the first step, a table of all the symbols is built, with their associated numerical values, and in the second step, all the symbols that appear in the operands of the program's instructions are replaced with their numerical values. Performing these two steps involves two scans (called "passes") of the source file. 
			- In the first pass, a symbol table is built in memory. In the example above, the symbol table after the first pass is:


```
| symbol | value |
|--------|-------|
| SZ     | 2     |
| MAIN   | 100   |
| LOOP   | 104   |
| L1     | 120   |
| END    | 124   |
| len    | 4     |   
| STR    | 125   |
| LIST   | 132   |
| K      | 135   |
```






 > [!info] Note: the role of the assembler, in its two passes, is to translate a source file into machine code.  At the end of the assembler operation, the program is not yet ready to be loaded into memory for execution. The machine code must go to the linking/loading stages, and only then to the execution stage (these stages are not part of this project). 

##### The First Pass

- the symbols (labels) that appear in the program must be identified, and each symbol must be given a numerical value which is the memory address that the symbol represents. 

- Rules are required to determine which address will be associated with each symbol.
- The basic principle is to count the places in memory that the instructions occupy. If each instruction is loaded in memory to the location following the previous instruction, such a count will indicate the address of the next instruction.
- The counting is done by the assembler and held in the **instruction counter** (IC). 
- The initial value of IC is `100` (decimal), so the machine code of the first instruction is constructed so that it is loaded into memory starting at address `100`. 
- The IC is updated on each line an instruction that allocates space in memory. After the assembler determines the length of the instruction, the IC is increased by the number of cells (words) occupied by the instruction, and thus it points to the next free cell. 


- As mentioned, in order to encode the instructions in machine language, the assembler has a table, which has a corresponding opcode for each operation name. During translation, the assembler replaces each operation name with its code, and each operand is replaced with a suitable encoding, but this replacement operation is not so simple. The instructions use a variety of [[#Addressing Modes]] for operands. The same action can have different meanings, in each of the addressing modes, and therefore different codings will suit it according to the addressing mode. 
	- For example, the move operation `mov` can refer to copying the contents of a memory cell to a register, or copying the contents of a register to another register, and so on. A different encoding may be appropriate for each such option of `mov`. 


- The assembler must scan the instruction line in its entirety, and decide on the encoding according to the operands. Usually the coding is divided into the field of the name of the operation, and additional fields that contain information about the addressing modes. All the fields together require one or more words in the machine code. 
- When the assembler encounters the label that appears at the beginning of the line, it knows that it has a definition of a label in front of it, and then it associates it with Maan - the current content of the IC. This is how all the labels receive their punishments during the definition. These labels are inserted into the symbol table, which contains, in addition to the label name, the addressee and other characteristics. When there is a reference to a label in the operand of some instruction, the assembler will be able to retrieve the appropriate address from the symbol table. 



- An instruction can also refer to a symbol that has not yet been defined in the program, but will only be defined later in the program. Below is an example, a branching instruction for that is defined by the label A that appears only later in the code: `bne A ...(after some lines)... A: ...`. When the assembler reaches the branch line (`bne A`), it has not yet encountered the definition of label A and of course does not know the address associated with the label. Therefore the assembler cannot build the binary encodingof the operand A. We will see later how this problem is solved. 


In any case, it is always possible to build in the first pass the full binary encoding of the first word of each instruction, the binary encoding of the additional information word of an immediate operand, or register, as well as the binary encoding of all the data (obtained from the instructions `.string`, `.data`).

##### The Second Pass

- using the symbol values, as well as the opcodes and register numbers, it builds the machine code. 

- In the second pass, the source code is converted to machine code. 
- At the beginning of the second pass, the values of the symbols should already be known.
- We saw that in the first pass, the assembler cannot construct the machine code of operands that use symbols that have not yet been defined. Only after the assembler has gone through the entire program, so that all symbols have already entered the symbol table, can the assembler complete the machine code of all operands. For this purpose, the assembler performs an additional pass (second pass) over the entire source file, and updates the machine code of the operands that use symbols, using the symbol values from the symbol table. At the end of the second pass, the program will be completely translated into machine code.

#### Errors

#todo 

#### Two-Pass Assembler Algorithm

> note: there is no obligation to use this algorithm

- We divide the machine code into two areas, 
	- The instruction area (code)
	- The data area (data)
	- Each area has its own counter, and they are called IC (Instruction-Counter) and DC (Data-Counter).
	- We will construct the machine code so that it is suitable for loading into memory starting at address 100. 
	- We mark with `L` the number of words that the machine code of a given instruction

##### First Pass Algorithm

1. Initialize `DC=0`, `IC=0`. 
2. Read the following line from the source file. If the source file runs out, go to 16. 
3. Is this a `.define` (constant)? If not, go to 5.
4. Insert the constant name into the symbol table with the `mdefine` property. Its value will be as it appears in the definition. (If the symbol is already in the table, an error must be thrown). Return to 2. 
5. Is the first field in the row a symbol? If not, go to 7. 
6. Turn on the "symbol-definition-exists" flag. 
7. Is this a directive to store data, (.`data` or `.string`)? If not, go to 10. 
8. If there is a symbol (label) definition, insert it into the symbol table with the `.data` property. Its value will be `DC`. (If the symbol is already in the table, an error must be thrown). 
9. Identify the data type, encode it in memory, and update the data counter DC according to its length. If this is a `.data` directive., and it has a data that is a symbol, check that the symbol appears in the table with the `mdefine` property, and use its value. (If the symbol is not in the table or is not `mdefine`, an error should be reported). go back to 2. 
10. Is this an `.extern` or `.entry` directive? If not, go to 12. 
11. Is this an `.extern` directive? If so, insert each symbol (one or more) that appears as an operand of the directive into the symbol table without a value, with the `.external` property. go back to 2. 
12. If there is a symbol definition, insert it into the symbol table with the code property. Its value will be `100 + IC` (if the symbol is already in the table, an error must be thrown). 
13. Look for the operation name in the operation table, if not found throw an error in the name of the instruction. 
14. Analyze the structure of the instruction's operands and calculate L. Now construct the binary code of the first word of the instruction. 
15. `IC = IC + L`, and return to 2. 
16. The source file is read in its entirety. If errors are found on the first pass, stop here. 
17. Update the symbol table with the value of each symbol characterized as `data`, by adding the value `IC + 100` (see explanation below)
18. Start a second pass


##### Second pass algorithm 

1. Initialize `IC = 0` 
2. Read the next line from the source file. If the source file is over, go to 9. 
3. If the first field is a symbol, skip it. 
4. Is this a `.data` or `.string` or `.extern` directive? If so, go back to 2. 
5. Is this an `.entry` directive? If not, go to 7
6. Mark in the symbol table the corresponding symbols in the `.entry` property. Return to 2. 
7. Complete the encoding of the operands starting from the second word in the binary code of the instruction, according to the addressing method. If an operand contains a symbol, find the value in the symbol table (if the symbol is not in the table, throw an error). 
8. Update `IC = IC + L`, and return to 2 
9. The source file is read in its entirety. If errors are found on the second pass, stop here. 
10. Build the output files (more details below).

### Assembler Operation Details


In addition to the outline algorithm provided earlier, let's expand on how the assembler operates.

The assembler maintains two arrays, referred to as the **instruction array** (מערך ההוראות) and the **data array** (מערך הנתונים). These arrays essentially represent the machine memory (each entry's size in these arrays is the same as that of a machine word: 14 bits). 

- The instruction array stores the encoding of machine instructions encountered during the traversal of the source file.
- The data array stores the encoding of data read from the source file (lines of the type `.string` and `.data`).

The assembler has two counters: **Instruction Counter** (IC) and **Data Counter** (DC). These counters indicate the next available location in the respective arrays. When the assembler starts processing a source file, both counters are reset.

- **The Symbol Table**: The assembler maintains a symbol table, where all labels encountered during file traversal are collected. This table, also known as the symbol table, stores the name, value, and various attributes previously defined, such as location (data or code), or update mode (relocatable or external).

The assembler reads the source file line by line, determining the type of each line (constant, instruction, directive, comment or empty line), and acts accordingly:


#### Empty or comment line 

The assembler ignores the line and proceeds to the next one.

#### Constant line

The assembler adds the constant name to the symbol table with the `mdefine` attribute.


#### Instruction line

- The assembler identifies: 
	- the operation 
	- addressing modes of the operand(s). (The number of operands it seeks is determined based on the instruction)

For each operand, the assembler determines its value as follows:

|  | Operand | Addressing Mode |
| ---- | ---- | ---- |
| Register | the register number | Register Addressing |
| Label | the value of the label as it appears in the symbol table (the label may not be present in the symbol table yet) | Direct Addressing - ישיר |
| `#` followed by a number or constant name (`.define`) | the number | Immediate Addressing - מיידי |

- The determination of the addressing method is done according to the operand's syntax, as explained above in the definition of addressing methods. For example, a number denotes immediate addressing, a label denotes direct addressing, and so on.

After the assembler analyzes the line and decides on the operation, the source operand addressing mode (if relevant) and the destination operand addressing mode (if relevant), it operates as follows:

- If it is an operation with two operands, then: 
	- the assembler enters into the instruction array, at the position indicated by the instruction counter (IC), the machine code of the first word of the instruction (in the instruction representation method as described earlier). This word contains the operation code and the addressing methods. 
	- Additionally, the assembler allocates space in the array for the additional words required for this instruction, and increments the instruction counter accordingly. If one or both operands are in register or immediate addressing mode, the assembler now encodes the relevant words in the instruction array.
- If it is an operation with only one operand, i.e., there is no source operand, then: 
	- the encoding is identical to above, except for the bits representing the addressing method of the source operand in the first word, which will always contain 0, since they are irrelevant to the operation.
- If it is an operation with no operands, then: 
	- only the first (and only) word is encoded. The bits representing the addressing methods of the two operands will contain 0.

> If there is a label in the instruction line, then the label is inserted into the symbol table under the appropriate name. the value of the label is the value of the instruction counter before encoding the instruction.

#### Directive line

When the assembler reads a directive line in the source file, it operates according to the type of directive as follows:

- `.data` 
	- The assembler does:
		- reads the list of numbers following `.data` 
		- inserts each number into the data array, 
		- increments the data counter (DC) by one for each number entered. 
	- Note that a defined constant name can also serve instead of a number
	- If there is a label in `.data` line, then: 
		- this label is inserted into the symbol table. 
		- the label's value is the value of the data counter (DC) before inserting the numbers into the data array. 
		- The label's type is relocatable, and it is marked as defined in the data section. 
		- At the end of the first pass, the label's value is updated in the symbol table by adding the instruction counter (IC) (i.e., adding the total length of encoding all instructions). The reason for this is that in the machine code image, the data are separated from the instructions, and all the data appear after all the instructions (see description of output files below).
- `.string` - Handling of `.string` is similar to `.data`, except that: 
	- the ASCII codes of the characters are those inserted into the data array (each character in a separate entry). 
	- Then the value `0` (indicating the end of the string) is inserted into the data array. 
		- The data counter (DC) is incremented by the length of the string + 1 (the extra space for the 0 at the end of the string).
		- Handling of a defined label in this line is the same as handling in the `.data` directive.
- `.entry` - This is a request for the assembler to insert the label appearing as an operand of `.entry` into the entries file. The assembler records the request, and at the end, that label will be recorded in the entries file.
- `.extern` - This is a declaration of a symbol (label) defined in another file, and which the assembly segment in the current file uses. 
	- The assembler inserts the symbol into the symbol table. Its value is 0 (the actual value is unknown and will only be determined at the linking stage), 
	- and its type is external. 
	- It is unknown in which file the definition of the symbol is located (and it doesn't matter for the assembler).


Note: In an instruction or directive, it is possible to use the name of a symbol whose declaration is given later in the file (either directly by defining a label or indirectly by using the `.extern` directive).

At the end of the first pass, the assembler updates in the symbol table every symbol characterized as data by adding 100+IC (in decimal) to its value. The reason for this is that in the complete picture of the machine code, the data are separated from the instructions, and all the data are required to appear after all the instructions. A symbol of type data is essentially a label in the data area, and the update adds to the symbol's value (i.e., its memory address) the total length of encoding all the instructions, plus the starting address of the code, which is 100.

The symbol table now contains all the necessary values for completing the encoding (except for values of external symbols).

In the second pass, the assembler encodes using the symbol table all the words in the instruction array that were not encoded in the first pass. These are words that need to contain addresses of labels (the ARE field in these words will be `10` or `01`).

### Input & Output Files

- **Input files:** ( `.as` files) source files written in the assembly language specified here. (e.g. `y.as`, `x.as`, and `hello.as`) (these files include the definition of the macros)
- When using the assembler, provide a list of source file names as command line arguments. 
- We need omit the extension. (e.g. if the assembler is called `assembler`, running `assembler x y hello` processes `x.as`, `y.as`, and `hello.as`.)

**Each input file processed individually**, resulting in the creation of the following output files:

| File                     | Ext.   | Content                                                                                                                                                                                                                                                         | Notes                                                                                                   |
| ------------------------ | ------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- |
| **Extended source file** | `.am`  | Source file after preprocessing (macro expansion).                                                                                                                                                                                                              | generate by the pre-assembler. If no macros are present, the `.am` file is identical to the `.as` file. |
| **Object file**          | `.ob`  | Machine code                                                                                                                                                                                                                                                    |                                                                                                         |
| **Entries file**         | `.evt` | Details about each symbol declared as an entry point (a symbol that appeared as an operand of the entry directive and is characterized in the symbol table as entry).                                                                                           | The file is omitted if there are no `.entry` directives                                                 |
| **Externals file**       | `.ext` | Details about all the places (addresses) in the machine code where a data word encoding the value of a symbol declared as external appears (a symbol that appeared as an operand of the extern directive and is characterized in the symbol table as external). | The file is omitted if there are no `.extern` directives                                                |

- Output file names are based on the input file names, for exmaple, running `assembler x` processes the file `x.as` and creates the files `x.ob`, `x.am` (and `x.ext`, and `x.ent` if needed)

#### Output Files Structure

##### Object File (`.ob`)

An object file contains the memory image. An object file consists of rows of text as follows:

- The first row in the object file is the "header," containing two numbers (in decimal): the total length of the instruction segment (in memory words) followed by the total length of the data segment (in memory words). There is one space between the two numbers.
- The subsequent rows in the file contain the memory image. Each row contains two values: the address of a word in memory, and the content of that word. The address is written in four-digit decimal (including leading zeros). The content of the word is written in "encoded" four-digit base 4 (see below), with leading zeros. There is one space between the two values in each row.
	- Instructions: The assembler constructs the memory image so that the encoding of the first instruction from the assembly file will enter the memory at address 100 (in decimal), the encoding of the second instruction will follow immediately after the first instruction (depending on the number of words in the first instruction), and so on until the last instruction.
	- Data: Immediately after encoding the last instruction, the data encoding generated by the `.string` and `.data` directives.
		- The data will be entered in the order they appear in the source file. 
		- An operand of an instruction that refers to a symbol defined in the same file will be encoded to point to the appropriate location in the memory image constructed by the assembler.


> Note that variables appear in the memory image after the instructions. This is why it is necessary to update the symbol table, at the end of the first pass, with the values of symbols defining data (symbols of type `.data`).

|     | Base 4 Encoding |
| --- | --------------- |
| `0` | `*`             |
| `1` | `#`             |
| `2` | `%`             |
| `3` | `!`             |
	##### Entries File (`.evt`)

- Each row consists of: 
	- the name of a symbol defined as `.entry` 
	- its value (in decimal) as found in the symbol table

##### Externals File (`.ext`)

- Each row consists of: 
	- the name of a symbol defined as `.extern` 
	- the address (in decimal) in the machine code where an operand referencing this symbol is encoded.

> Of course, there may be multiple addresses in the machine code referring to the same external symbol. Each such reference will have a separate row in the externals file

# General Guidelines

- The assembler's execution mode should be as required by the specification, without any changes. In particular, the user interface will be solely through the command line. Specifically, the names of the source files will be passed to the assembler as arguments on the command line. Interactive input menus, graphical windows, etc., should not be added.
- **Modularity**: It is important to modularize the implementation of the assembler into several modules (C language files) according to tasks. Different tasks should not be concentrated in a single module. Recommended modules include: 
	- first pass, 
	- second pass, 
	- helper functions (such as translation to binary, syntax analysis of a line), 
	- symbol table, 
	- memory map, 
	- constant tables (operation codes, legal addressing modes for each operation, etc.).
- Care should be taken to document the implementation thoroughly and clearly, using detailed comments in the code.
- It should be possible to have extra spaces in the assembly language input file. For example, if an instruction line has two operands separated by a comma, spaces and tabs are allowed before and after the comma, as well as before and after the operation name. Empty lines are also allowed. The assembler will ignore unnecessary spaces (i.e., skip over them).
- **Errors**: The input (assembly code) may contain syntax errors. The assembler should detect and report all incorrect lines in the input. Processing of the input file should not stop after the first error is detected. Detailed messages should be printed to the screen whenever possible, so that it will be possible to understand what and where each error is. Of course, if the input file contains errors, there is no point in generating the output files (`ob`, `ext`, `ent`) for it.

____

# Strurctures used in the assembler 

-  Any other data structure (such as the symbol table and macro table) should be implemented efficiently (for example, using a linked list and dynamic memory allocation).

### Label Table

   - This table associates labels with numbers. Each label is mapped to a numerical value, typically representing a memory address or a constant value.
   - It may have different sections for labels defined by directives like `.define`, `.data`, and instructions (`.code`).
   - Operations:
     - Insert: Add a new label and its associated number to the table.
     - Find: Retrieve the number associated with a given label.
     - Sort: Arrange the labels in a particular order, usually between passes.
     - FreeAll: Clear the label table.

### Machine Image Table

- This table holds the machine code generated by the assembler.
- It may store the binary representation of instructions, data values, and constants.
- Typically implemented as a constant-size array to represent memory.
- Operations:
	- None explicitly mentioned, but likely involves inserting machine code instructions or data values at specific memory addresses.
- The length of the assembly program, given as input to the assembler, is not known in advance, and therefore, the length of the translated program is not supposed to be predetermined. However, to facilitate the implementation of the assembler, a maximum size can be assumed. Therefore, it is possible to use arrays to store only the machine code image.

### Macro Table

- This table is specifically used for managing macros and their expansions.
- Implemented as a hash table for efficient lookup.
- Operations:
	- Insert: Add a new macro definition and its expansion to the table.
	- Get: Retrieve the expansion of a specific macro.
	- FreeAll: Clear the macro table.

### Define Table

- This table stores the definitions of constants using the `.define` directive.
- Can be implemented as either a hash table or a dynamic array.
- Operations:
	- Insert: Add a new constant definition and its value to the table.
	- Find: Retrieve the value associated with a specific constant.
	- FreeAll: Clear the define table.
